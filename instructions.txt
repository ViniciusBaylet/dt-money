# Primeira pasta a ser criada:
- styles
 global.ts
 themes
  default.ts

Coloca o <ThemeProvider> por volta do App no componente App.tsx
Define o theme={defaultTheme}

Cria a pasta @types (arquivo de tipagem do styled components)
Cria o arquivo styled.d.ts

Cria temas globais no arquivo global.ts

Importa o <GlobalStyle /> no arquivo App.tsx


# Segunda pasta a ser criada:
- assets
importar a logo do site e demais imagens


# Terceira pasta a ser criada:
- pages
 Transactions


# Quarta pasta a ser criada:
- components
 Header

# Radix UI:
- biblioteca para criar o dialog (npm install @radix-ui/react-dialog)
- vai no Header que é onde fica o botão que vai ativar o dialog e coloca a tag <Dialog.Root> por volta do botão
- bota a tag <Dialog.Trigger> por volta do botão e passa a propriedade "as child" para que o trigger não crie outro botão e aproveite o botão que já está dentro dele (<NewTransictionButton>)

# JSON Server:
- Simula uma API para que consigamos fazer requisições para um backend ficticio (npm i json-server -D)
- Criar arquivo server.json
- Cada propriedade do objeto = uma rota da aplicação ou uma entidade do banco de dados
- Para rodar o JSON Server utiliza-se o comando: npx json-server server.json -w ou json-server server.json -w -p 3333 (para subir na porta 3333)
- Cria o script dev:server no package.json

# Requisições HTTP:
- Para carregar uma lista de qualquer coisa no backend utilizamos a API fetch() do navegador (caso não queiramos instalar nenhuma biblioteca). Porém, sempre que o componente que o fetch está inserido mudar, a requisição do fetch será realizada novamente(não queremos isso pois acaba perdendo performance).
sintaxe: fetch("http://localhost:3000/transactions").then(response => {
        console.log(response)
    });
- Por isso usamos o fetch dentro do useEffect();
sintaxe:    useEffect(() => {
        fetch("http://localhost:3000/transactions")
        .then(response => response.json())
        .then(data => console.log(data));
    }, []);
- Porém dessa forma não conseguimos colocar async-await pois não podemos usar isso na função do useEffect. A solução é separar a requisição em uma função js e chamar essa função dentro do useEffect.
sintaxe:
    async function loadTransactions() {
        const response = await fetch("http://localhost:3000/transactions");
        const data = await response.json();
        console.log(data);
    }

    useEffect(() => {
        loadTransactions();
    }, []);
- Precisamos armazenar essas informações que chegam da API num estado.
- Importante tipar os estados usando type ou interface
- Toda vez que eu fizer um map o primeiro elemento do map tem que ter um atributo key que o identifica unicamente

# Quinta pasta a ser criada:
- contexts
 TransactionContext
- Mover toda a parte de chamada para a api para dentro do contexto
- Coloca o <TransactionsProvider> por volta do <Transactions> no arquivo App.tsx
- Importa os atributos usando o hook useContext no <Transactions>
- Importa a linha: const { transactions } = useContext(TransactionsContext); para dentro do componente <Summary> para ter acesso aos dados da API e calcular entradas, saidas e total.

# Sexta pasta a ser criada:
- utils
 formatter
para lidar com formatações (de dinheiro, datas e etc);- altera os atributos na pagina de <Transactions>
{priceFormatter.format(transaction.price)}

# Criando hooks próprios:
- são funções que retornam hooks nativos do React

# React-Hook-Form:
- Para inserir uma informação que não vem de um campo nativo de um elemento do html precisamos utilizar uma API do react-hook-form para controlar essas informações (control do useForm)
- Colocar <TransactionType> dentro do render do <Controller> no arquivo <NewTransactionModal>

# Axios:
- Biblioteca para fazer requisições http;

# Sétima pasta a ser criada:
- lib
 axios.ts

# Atualizando a lista de transactions após cadastrar nova transaction:
- Não seria interessante chamar a função fetchTransactions() dentro da função handleCreateNewTransaction() pois a função handle já faz uma requisição do tipo post e faria outra do tipo get
- A solução é criar uma função que faça a requisição do tipo post dentro do context(createTransaction())
- Passa a função createTransaction() através do contexto.
- Chama a função no <NewTransactionModal>

# Context Selectors
- Não é possível falar para o componente olhar apenas para a variável do contexto ao qual ele está chamando. Ele vai olhar para todos os componentes que pertencem ao contexto, mesmo que não esteja sendo chamado dentro do componente
- Lá no contexto, ao invés de chamar o createContext do react, vamos chamar o createContext que vem dentro do use-context-selector
- Ao invés de usar o useContext para chamar esse contexto nos componentes, usaremos agora o useContextSelector
- Colocamos uma função como segundo parametro e essa função retorna o componente ao qual queremos ficar observando as mudanças e não todos os elementos como era antes.

# useCallback
- Evita com que alguma função seja recriada em memória se nenhuma informação que aquela função dependa tenha mudado
- Como usamos useCallback no fetchTransactions => devemos passar fetchTransactions no array de dependencias do useEffect no context.

# memo
- Usado quando para evitar lentidão quando o componente tem um return MUITO grande;
- sintaxe:
const searchFormSchema = z.object({
    query: z.string()
});

type SearchFormInputs = z.infer<typeof searchFormSchema>;

function SearchFormComponent() {
    const fetchTransactions = useContextSelector(TransactionsContext, (context) => {
        return context.fetchTransactions;
    });

    const { register, handleSubmit, formState: { isSubmitting } } = useForm<SearchFormInputs>({
        resolver: zodResolver(searchFormSchema)
    });

    async function handleSearchTransactions(data: SearchFormInputs) {
        await fetchTransactions(data.query);
    }

    return (
        <SearchFormContainer onSubmit={handleSubmit(handleSearchTransactions)}>
            <input type="text" placeholder="Pesquise uma transação" {...register('query')} />
            
            <button type="submit" disabled={isSubmitting}>
                <Search size={15} />
                Buscar
            </button>
        </SearchFormContainer>
    )
}

export const SearchForm = memo(SearchFormComponent);

# useMemo
- igual o memo porém ao invés de memorizar componentes, ele memoriza variáveis;
- usado quando temos cálculos complexos nos compoenentes;